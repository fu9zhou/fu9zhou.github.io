{"posts":[{"title":"Win11开启安卓子系统","text":"&emsp;&emsp;Windows 11的安卓子系统支持用户在Windows环境中运行Android应用程序。本文介绍了如何启用Windows 11的虚拟化技术并安装适用于Android的Windows子系统（WSA），以此在Windows电脑上运行Android应用。 开启VT虚拟化要在Windows 11上运行Android应用，必须启用虚拟化技术。请按照以下步骤完成设置： 开启Hyper-V和虚拟机平台 进入Windows功能设置，勾选“Hyper-V”和“虚拟机平台”。 主板设置 以华硕主板为例，在BIOS中开启Intel (VMX) Virtualization Technology（虚拟化技术）和VT-d（IOMMU）。其他品牌主板的用户，可以参考百度教程来启用虚拟化。 验证虚拟化是否开启 打开任务管理器，切换到“性能”标签，在“CPU”部分查看是否显示虚拟化已启用。 安装WSA可以通过以下两种方式之一进行安装： 通过 Microsoft Store 安装 在 Microsoft Store 中搜索并安装 Amazon AppStore，系统会自动安装 Windows Subsystem for Android (WSA)。 手动安装（如果无法通过 Microsoft Store 安装） 下载系统安装包 访问这个网站，搜索 ProductId: 9P3395VX91NR，下载带有 .msixbundle 扩展名的文件。 在管理员模式下打开PowerShell终端，执行 Add-AppxPackage -Path &quot;文件路径&quot; 命令安装。 尝试启动适用于Android的Windows子系统，若显示虚拟化问题，在管理员终端运行 bcdedit /set hypervisorlaunchtype auto 并重启即可。 安装Android应用安装WSA后，需要通过ADB工具在Windows 11上安装Android应用： 下载ADB，并在解压后的文件内打开终端，以使用adb安装 打开适用于Android的Windows子系统，在高级设置中开启开发人员模式 在终端中输入 adb connect 127.0.0.1:58526 连接，并在弹出窗口中同意ADB连接 在终端中输入 adb install &quot;APK文件路径&quot; 安装","link":"/2023/07/29/Win11%E5%BC%80%E5%90%AF%E5%AE%89%E5%8D%93%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"title":"Win11恢复默认右键菜单","text":"&emsp;&emsp;Windows 11为了让界面更好看，在右键菜单中隐藏了很多项目，一直点击显示更多确实有点烦了。本文将介绍如何通过几种方式，恢复Windows 10的右键菜单。 改资源管理器选项 文件资源管理器-选项 查看-在单独的进程中打开文件夹窗口 此方法还会同时将其他内容还原到旧的 Windows 10 样式 使用终端恢复 按 Win+S 打开搜索框，找到 cmd 并以管理员身份运行命令提示符 输入以下命令并按Enter键执行 1reg add HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}\\InprocServer32 /ve /d “” /f 注：恢复方法 1reg delete &quot;HKCU\\Software\\Classes\\CLSID\\{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}&quot; /f 修改注册表 按 Win+R 输入 regedit 打开注册表编辑器 导航到： HKEY_CURRENT_USER\\SOFTWARE\\CLASSES\\CLSID 右键单击 CLSID 并选择“新建”&gt;“项”，然后将其命名为：{86ca1aa0-34aa-4e8b-a509-50c905bae2a2} 再次右键单击刚刚新建的项，然后选择“新建”&gt;“项”，并将其命名为 InprocServer32 双击右侧面板中的（默认），然后将其数值数据设置为空白，单击“确定” 注：恢复方法 在注册表编辑器中删除此项：{86ca1aa0-34aa-4e8b-a509-50c905bae2a2}","link":"/2023/02/08/Win11%E6%81%A2%E5%A4%8D%E9%BB%98%E8%AE%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"title":"箭头函数","text":"&emsp;&emsp;箭头函数是 ES6 引入的一项重要特性，它使得函数的定义更加简洁和灵活。相比传统的函数表达式，箭头函数在语法上更加简洁，并且具有不同的 this 绑定方式，常用于回调函数和简化代码的场景。本文将详细介绍箭头函数的基本语法、常见用法以及 this 的指向规则，帮助你更好地理解和使用箭头函数。通过本文，你将能够在开发中高效地应用箭头函数，提升代码的可读性和简洁性。 基本用法箭头函数的基本语法比传统函数表达式更加简洁。通过箭头 (=&gt;) 来定义函数，可以省去 function 关键字和大括号。 参数如果箭头函数没有参数，不可以省略参数的括号： 123let greet = () =&gt; { console.log(&quot;Hello, World!&quot;);}; 如果箭头函数只有一个参数，可以省略参数的括号： 1let square = x =&gt; x * x; 如果箭头函数有多个参数，必须使用括号包裹它们： 1let sum = (a, b) =&gt; a + b; 函数体箭头函数的函数体可以有多行，也可以只有一行。当函数体只有一行时，可以省略大括号并自动返回结果。 如果箭头函数的函数体有多行代码，就需要用大括号包裹，并显式地使用 return 来返回值： 1234let multiply = (a, b) =&gt; { let result = a * b; return result;}; 如果箭头函数的函数体只有一行代码，可以省略大括号，并且函数的结果会自动返回： 123let double = x =&gt; x * 2;console.log(double(5)); // 输出: 10 如果箭头函数返回一个对象字面量，需要用圆括号将对象包裹起来，避免与函数体的 {} 混淆： 如果不加括号，JavaScript 会误认为 {} 是函数体的一部分，从而导致语法错误。 123let getPerson = () =&gt; ({ name: &quot;Alice&quot;, age: 30 });console.log(getPerson()); // 输出: { name: &quot;Alice&quot;, age: 30 } 进阶用法用于数组迭代箭头函数在处理数组时，尤其是在 map()、filter()、reduce() 等方法中，能够显著提升代码的简洁性和可读性。 123456789let numbers = [1, 2, 3, 4, 5];// 使用箭头函数过滤出偶数let evenNumbers = numbers.filter(number =&gt; number % 2 === 0);console.log(evenNumbers); // 输出: [2, 4]// 使用箭头函数将数组中的每个元素乘以 2let doubledNumbers = numbers.map(number =&gt; number * 2);console.log(doubledNumbers); // 输出: [2, 4, 6, 8, 10] 简化单行函数当箭头函数的函数体只有一行时，可以省略大括号和 return，让代码更加简洁。 1let add = (a, b) =&gt; a + b; 这种简化语法非常适用于执行简单的计算或返回结果的函数。 用于处理 setTimeout 或其他异步操作箭头函数非常适合用于异步操作，因为它会继承外部函数的 this，避免了传统函数中 this 指向丢失的问题。 123456789function Timer() { this.time = 0; setInterval(() =&gt; { this.time++; // this 指向外部的 Timer 对象 console.log(this.time); }, 1000);}let timer = new Timer(); // 输出 1, 2, 3, ... 用于处理 arguments箭头函数没有自己的 arguments 对象，它会继承外部函数的 arguments。需要处理不定参数的场景，推荐使用箭头函数。 12345function sum() { return Array.from(arguments).reduce((acc, num) =&gt; acc + num, 0);}console.log(sum(1, 2, 3, 4)); // 输出: 10 在箭头函数中，如果尝试访问 arguments，会报错，因为它没有该属性。 如果需要访问外部函数的 arguments，可以使用普通函数。 与传统函数的区别 this 的指向不同 箭头函数没有自己的 this，它会继承外部环境中的 this，而传统函数的 this 取决于函数的调用方式。 不能作为构造函数 箭头函数不能作为构造函数使用，因为它没有 prototype 属性。 不具备 arguments 对象 箭头函数没有自己的 arguments 对象，若需要访问传入参数，可以使用外部函数的 arguments。 没有 super 和 new.target 箭头函数没有 super 和 new.target，这使得它无法在类方法中使用 super 来调用父类的方法。 使用箭头函数的优势 简洁的语法 箭头函数最显著的特点就是简洁，它减少了很多冗余的语法，使得代码更简洁，易读。特别是在需要传入匿名函数的地方，比如数组的 map()、filter()、reduce() 等方法，箭头函数显得非常有优势。 自动绑定 this 箭头函数的 this 继承自外部函数的执行上下文，这使得它特别适用于处理回调函数，避免了传统函数中 this 指向丢失的问题。在传统函数中，this 的指向依赖于函数的调用方式，常常需要通过 .bind()、.call() 或 .apply() 来显式绑定。而箭头函数自动绑定 this，避免了这个麻烦。 没有自己的 arguments 对象 箭头函数没有自己的 arguments 对象，它会继承外部函数的 arguments。如果需要访问函数的参数，可以直接使用外层函数的 arguments。这对于处理不定参数的函数尤其有用。","link":"/2023/08/09/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"},{"title":"宝塔面板部署Vue项目","text":"&emsp;&emsp;宝塔面板（BT Panel）是一款功能强大的服务器管理工具，支持网站、数据库、FTP、SSL等多种服务的管理，适用于各种Web项目的快速部署和管理。本文将重点介绍如何使用宝塔面板部署 Vue 项目。通过这些步骤，你可以快速将本地开发的 Vue 项目部署到服务器上，确保项目在服务器上能够稳定运行。 本地运行解压文件解压他人发给你的vue项目，如果这个vue项目里有node_modules这样的包的文件，在解压后把他们删除，重新下包 建议：在压缩vue项目时就删除这些文件，减少压缩包的大小 下载包在cmd中使用命令npm install下载vue项目的包 注：如果下载速度过慢，可以使用npm config set registry https://registry.npm.taobao.org切换淘宝镜像 运行下载完成后输入npm run dev运行，确保项目在本地可以正常运行 部署宝塔本文只介绍vue部署的部分，在部署vue之前，可以先把后端部署到服务器并更改好本地项目的api地址 构建项目在cmd面板运行npm run build构建项目，构建完成会出现如下提示 在项目目录中会有生成一个dist文件夹 上传文件将dist文件夹压缩，上传至宝塔面板-文件-wwwroot下的项目文件夹内并解压缩（解压后可以删除压缩包） 添加站点选择网站-PHP项目-添加站点，并按下图设置 域名处可为网站的服务器地址（默认80端口）或者添加好的域名 根目录为刚才上传dist文件的目录 注意：如果使用的服务器地址IP，但是不是80端口，需要在云服务器和宝塔面板中对端口进行放行。 此时访问设置的这个地址，就可以看到部署好的网站了。","link":"/2023/12/10/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E9%83%A8%E7%BD%B2Vue%E9%A1%B9%E7%9B%AE/"},{"title":"在Markdown中插入PDF","text":"&emsp;&emsp;在使用 Markdown 撰写技术文档或报告时，插入外部文件是一个常见需求。由于 Markdown 的特性，我们可以通过使用适当的 HTML 标签，可以将文件嵌入到 Markdown 文档中，提升文档的完整性和互动性。本文将详细介绍如何在Markdown中插入 PDF 文件。 在Markdown中插入文件的方法有多种，其中一种简单且常用的方式是通过HTML的&lt;embed&gt;标签。 &lt;embed&gt;标签允许你将外部文件嵌入到Markdown页面中，具体的实现方式如下： 1&lt;embed src=&quot;文件链接&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;600&quot;&gt; 参数说明： src：指定要嵌入的文件链接，通常是一个PDF文件的URL。 type：指定文件类型。对于PDF文件，使用application/pdf。 width：设置嵌入文件的宽度，可以使用百分比或像素值。100%表示全宽。 height：设置嵌入文件的高度，可以使用像素值。比如600表示高度为600像素。","link":"/2024/12/22/%E5%9C%A8Markdown%E4%B8%AD%E6%8F%92%E5%85%A5PDF/"},{"title":"git的克隆与上传","text":"&emsp;&emsp;Git 是一个分布式版本控制系统，用于追踪代码的变更历史，帮助开发者高效地管理和协作开发。通过 Git，开发者可以轻松地进行代码的分支管理、合并、版本回溯等操作，是现代软件开发中不可或缺的工具。本文将以 Gogs 为例介绍如何使用 Git 克隆已有的仓库并将本地修改上传到远程仓库。 安装GitmacOS安装地址：Git - Downloading Package (git-scm.com) windows安装地址：Git - Downloading Package (git-scm.com) 无需任何配置，全程下一步即可。 从云端克隆仓库进入已有的gogs仓库，即可看见仓库地址，本文中的仓库地址以http://localhost:3000/pixelvox/test.git为例 由于是已经建好的仓库，我们不再需要使用git init创建仓库，我们直接使用git clone 仓库地址克隆仓库即可。 注意：我们可以在需要克隆仓库的目录下运行cmd终端或右键选择Git Bash here来在当前地址下运行终端 如果是私密仓库，则会弹出此窗口让你输入用户名和命名。 有时，不会弹出窗口，你也可以在命令行中输入账号和密码 注意：在命令行中输入密码时不会有提示已经输入，保证密码输入正确按回车即可 出现如下提示则说明仓库已成功克隆到本地 管理本地仓库在克隆下来的本地仓库内，你可以进行文件的修改，完成后，参考如下方式提交 下面的命令都是最基本的git命令，如果想要学习更详细的git知识，可以参考下面这篇教程 Git 使用教程：最详细、最傻瓜、最浅显、真正手把手教！（万字长文）-CSDN博客 注意：我们需要进入仓库后运行git相关的命令 方法：在仓库所才在文件夹的地址栏直接输入cmd或右键选择Git Bash here在仓库地址下进入仓库 注意：之前打开的那个终端此时处于仓库外，使用git命令，可以使用 cd 仓库名进入仓库 git add：将文件添加到暂存区。 12git add &lt;file&gt; # 添加指定文件git add . # 添加所有修改的文件（推荐使用） git commit：提交更改并保存到本地仓库。 一旦文件被添加到暂存区，可以使用git commit命令将这些更改提交到本地仓库，并生成一个新的提交记录。 -m后的信息用于添加对本次提交的描述，需要使用&quot;&quot;包裹，内容可以是中文 1git commit -m &quot;提交描述&quot; # 提交并添加提交信息 git push：将本地仓库的更改推送到远程仓库。 注意：如果是git push origin master，则可以简化为git push 部分仓库第一次使用此命令时可能需要再次输入账号密码。 1git push origin master # 将本地仓库的更改推送到远程仓库的指定分支 错误解决 如果你在使用git commit命令时出现这个提示，则表明你没有配置你的邮箱，本地仓库需要是谁提供的这次commit 123#you@example.com/Your Name替换为自己的邮箱/用户名即可（任何邮箱/用户名都可以，没有影响）git config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 想了解详细内容可以参考这个文档：添加和删除git全局配置（git config –global）_git global config-CSDN博客 小结简单来说，你想完成从仓库克隆并上传，一共就以下4+1条命令 克隆仓库：git clone 仓库地址（可能需要密码） 进入仓库：cd ./仓库名 加入暂存：git add . 提交本地：git commit -m &quot;提交描述&quot;（可能需要配置本地的用户名和邮箱） 推送远程：git push origin master或git push（可能需要密码）","link":"/2024/03/27/git%E7%9A%84%E5%85%8B%E9%9A%86%E4%B8%8E%E4%B8%8A%E4%BC%A0/"},{"title":"this指向","text":"&emsp;&emsp;在使用 JavaScript 时，this 的指向常常需要通过不同的方法进行绑定。常见的三种方法包括 apply、bind 和 call，它们的作用是将函数的 this 指向明确地绑定到特定的对象上。每种方法有其适用场景和特点，了解它们的区别和使用方法，有助于更好地控制函数执行时的上下文。以下是三种方法的详细介绍及其使用场景。 代码片段：20241119_改变this指向 apply 语法：函数.apply( this指向, [函数参数] ) 应用：适合需要将函数参数列表动态传递的场景，比如从数组中解构参数。 12345678function opFn(arg1, arg2) { console.log(this) console.log(arg1, arg2)}const thisObj = {name:&quot;allen&quot;}opFn.apply(thisObj,[1,2]) call 语法：函数.call( this指向, 函数参数1, 函数参数2, ... )（与 apply 唯一的区别就是函数参数的传递方式，是逐个列出还是以列表形式传递） 应用：适合参数固定的场景，直接传入参数列表。 12345678function opFn(arg1, arg2) { console.log(this) console.log(arg1, arg2)}const thisObj = {name:&quot;allen&quot;}opFn.call(thisObj,1,2) bind 语法：函数.bind( this指向, 函数参数1, 函数参数2, ... ) 特点：不会立即调用这个函数，而是返回一个新函数，这个函数的 this 指向已被永久绑定为指定值。 应用：可以用于创建带有固定上下文的函数，或者应用于需要提前绑定部分参数的情况。 备注：我个人很喜欢用它来给onClick来绑定回调函数，因为他返回的是函数，而不是立即执行的结果。 123456789function opFn(arg1, arg2) { console.log(this) console.log(arg1, arg2)}const thisObj = {name:&quot;allen&quot;}const bindFn = opFn.bind(thisObj,1,2)bindFn() 小结 特性 apply call bind 是否立即调用 是 是 否 参数形式 数组或类数组（[arg1, arg2]） 逐个列出（arg1, arg2） 逐个列出（可绑定部分参数） 返回值 函数调用的返回值 函数调用的返回值 返回一个绑定 this 的新函数 使用场景 参数已是数组形式 参数固定且逐个列出 创建新函数并绑定 this 供后续调用","link":"/2024/11/19/this%E6%8C%87%E5%90%91/"},{"title":"nvm的使用方法","text":"&emsp;&emsp;nvm（Node Version Manager）是一个用于管理和切换多个 Node.js 版本的工具。本文介绍了如何在 Windows 系统上安装和配置 nvm，并提供了一些常用的命令。 下载软件下载地址：https://github.com/coreybutler/nvm-windows/releases 直接下载最新的nvm-setup.exe，全程下一步安装即可。 常用命令nvm list：列出已安装的 node 版本 nvm list available：列出可安装的 node 版本 npm use 版本号：切换指定版本 npm install 版本号：安装指定版本 npm uninstall 版本号：卸载指定版本 说明：以上版本号可以写a.b.c指定详细版本，也可以直接写a来指定大版本号 注：第一次在 PowerShell 运行时可能会报禁止执行脚本，这是由于脚本权限导致的，执行下面的命令来修改。 Restricted：默认， 不允许任何 script 运行AllSigned：所有 script 需要数字签名RemoteSigned：本地 script 不需要数字签名，网络 script 需要数字签名Unrestricted：允许任何 script 运行 12345# 获取当前策略Get-ExecutionPolicy# 设置当前策略Set-ExecutionPolicy 策略名Set-ExecutionPolicy RemoteSigned 配置镜像源nvm 的镜像源进入nvm的软件安装目录，打开settings.txt文件，添加后两行转到指定 node 的镜像源。 1234root: C:\\Users\\allen\\AppData\\Roaming\\nvmpath: C:\\Program Files\\nodejsnpm_mirror:npmmirror.com/mirrors/npm/node_mirror:npmmirror.com/mirrors/node/ npm 的镜像源查询：npm config get registry 更换：npm config set registry https://registry.npmmirror.com/ 恢复：npm config set registry https://registry.npmjs.org/ 删除注册表：npm config delete registry（解决恢复官方源后还不能使用npm search等命令的问题） 拓展：也可以使用 nrm 进行镜像源管理 安装 nrm：npm install -g nrm --registry https://registry.npmmirror.com/ 列出：nrm ls 切换：nrm use &lt;registry&gt; 增加：nrm add &lt;registry&gt; &lt;url&gt; 删除：nrm del &lt;registry&gt; 测试：nrm test &lt;registry&gt; 注：如果上面的npm_mirror已经配置了，可以不用修改 node 的镜像源。 yarn 的镜像源查询：yarn config get registry 更换：yarn config set registry https://registry.npmmirror.com/ 恢复：yarn config set registry https://registry.yarnpkg.com/ 删除注册表：yarn config delete registry","link":"/2024/08/21/nvm%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"博客写作规范","text":"&emsp;&emsp;新年新气象，在开发过程中，越发经常的遇到以前解决过的问题，却忘记了具体的解决方案。为了避免这种情况的再次发生，我决定今年开始使用 Hexo 记录我的学习过程和问题解决方案。通过写博客，帮助自己整理思路，也能方便日后查找参考。下面是一些我总结的 Hexo 使用技巧以及博客写作的建议，留作自己日后查阅。本文只会从网络提取一些对我个人比较重要的写作规范，完整资料请从参考文章中获取。 文章结构标题 少用三级，不用四级 标题下应有描述，避免多层标题重叠 不跨级使用、不孤立编号、不与上级同名 正文 句号：中文句尾用全角；句号应写在括号外 逗号：避免“一逗到底”，即全部停顿都使用逗号 括号：名称统一，如 {} 大括号、 [] 方括号、 &lt;&gt; 尖括号、 （） 圆括号 文本：中英文之间留一个空格（与标点符号不留空格）；区别增加/降低（了/到） 句子：尽量用肯定句；避免双重否定句；中文书名号，英文双引号 Markdown 引用：标记文章/图片来源 代码：单行用 code 进行包裹，多行用代码块进行包裹 链接：明确链接标题，如果需要显示链接来源，可以用 | 或 - 进行分隔 Hexo使用文章草稿由于我配置的发布后的文件名为 日期+标题 ，会影响相对路径，所以不适用 Hexo 默认的草稿模板。 如果需要，直接把文章手动移动到 _drafts 文件夹下即可不在页面中显示，发布时直接从文件夹中移出即可。 文章摘要尽量给文章写摘要/前言，明确文章的内容，建议使用&amp;emsp;进行首行缩进。 如无：默认提取内容（不含代码块）的前200个字符。 如有：在该部分后添加&lt;!--more--&gt;标签，让 Hexo 正确识别摘要的内容。 文章跳转如果需要跳转到同站点的其它博客，使用{% post_link 文章原标题（必填） 文章显示标题（选填） %}来插入连接。 图片保存使用hexo new 文章标题或hexo n 文章标题来创建文章，会同时创建对应的文章图片文件夹。 如果文章中没有图片信息，建议删除该文件夹方便后续对文章的整理。 文章配置在文章的 Front-matter 中可以完成文章的配置，常用的项目有： 日期：date: 2000-01-01 12:00:00，需和文件名的日期保持一致 置顶：sticky: 大于0的正整数，此数值代表置顶文章的优先级，默认为0，建议不超过100 隐藏：hide: true 标签：用于标记主要语言，一般为大写全称（如：HTML、CSS、JavaScript、TypeScript、Go、Nginx） 1234567# 单标签tag: 标签# 多标签tag:- 标签1- 标签2 分类：用于标记文章分类，一般为二级分类（规定的大分类有：前端开发、后端开发、后端运维） 12345678# 单分类categories: 分类categories: [分类, 子分类]# 多分类categories:- 分类1- [分类2, 子分类] 说明：一般使用单标签+单分类，如果文章没有标签或者分类，建议保留初始化时的 yml 信息，方便后续添加。 样式修改如果需要对样式进行修改，可以直接修改主题的 npm 包。 使用 patch-package 执行 npx patch-package hexo-theme-icarus 对修改进行保存。 后期计划Cloudflare托管 Hexo博客搜索引擎优化 参考文章如何写好技术文档 | 程序员李林 如何用Hexo优雅的书写文章 | CSDN博客 开发者如何编写优雅的技术文档 | Frank’s 技术世界","link":"/2025/01/01/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/"},{"title":"Prisma中的环境变量","text":"&emsp;&emsp;在这里写前言 遇到问题Next支持.env、.env.development、.env.production、.env.local这样的环境变量，可以在生产和开发环境中使用不同的环境变量。但是如果我使用prisma管理数据库，就会遇到prisma的指令无法正确根据我当前的环境读取不同的数据库URL的情况。 相关知识Next的环境变量以下内容来自：环境变量 | Next.js 中文文档 .env：默认环境（所有环境都生效，最低优先级） .env.development：生产环境（next dev时生效） .env.production：开发环境（next start时生效） .env.local：本地环境（所有环境都生效，最高优先级） 优先级：.env&gt;.env.development/.env.production&gt;.env.local dotenvdotenv 是一个 Node.js 库，用于从 .env 文件中加载环境变量到 process.env 中。 在 Prisma 中，命令行默认从.env文件中读取文件，如果要指定其他的环境变量文件，就需要用到它的命令行工具 dotenv-cli。 安装：yarn add dotenv-cli -D 语法：dotenv -e 环境变量文件 -- 后续命令 例如：dotenv -e .env.development -- prisma db push NODE_ENVNODE_ENV 是 Node.js 应用中一个及其重要的环境变量，可以标识当前的运行环境（开发、生产、测试），我们可以在页面里使用它来实现开发环境自动填写测试用密码、跳过某些权限校验之类。 下面这个文件，可以实现在使用node 文件时直接指定环境，而不用单独配置。 executor.js 12345678910111213141516171819202122232425262728293031323334const { spawn } = require(&quot;child_process&quot;)// 默认配置let env = { ...process.env } // 保留原有环境变量let fileToExecute = null // 主逻辑文件路径// 解析命令行参数process.argv.forEach(arg =&gt; { // 设置环境变量 if (arg.startsWith(&quot;--env=&quot;)) { env.NODE_ENV = arg.split(&quot;=&quot;)[1] } // 获取文件路径 if (arg.startsWith(&quot;--file=&quot;)) { fileToExecute = arg.split(&quot;=&quot;)[1] }})// 检查是否指定了主逻辑文件if (!fileToExecute) { console.error(&quot;Error: No file specified. Use --file=&lt;path-to-file&gt; to specify the file.&quot;) process.exit(1)}// 输出调试信息console.log(&quot;NODE_ENV:&quot;, env.NODE_ENV)console.log(&quot;Executing file:&quot;, fileToExecute)// 使用子进程执行指定的文件const child = spawn(&quot;node&quot;, [fileToExecute], { env, stdio: &quot;inherit&quot; })child.on(&quot;exit&quot;, code =&gt; { console.log(`Child process exited with code ${code}`)}) 用法：node executor.js --env=production --file=./e.js 解决方案分别在.env.development和.env.production中写数据库的连接 URL ，然后在package.json中写对应脚本来执行数据操作。 1234&quot;scripts&quot;: { &quot;push:dev&quot;: &quot;dotenv -e .env.development -- prisma db push&quot;, &quot;push:pro&quot;: &quot;dotenv -e .env.production -- prisma db push&quot;}","link":"/2025/01/12/Next%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Bt","slug":"Bt","link":"/tags/Bt/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Prisma","slug":"Prisma","link":"/tags/Prisma/"}],"categories":[{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"前端开发","slug":"前端开发","link":"/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"后端运维","slug":"后端运维","link":"/categories/%E5%90%8E%E7%AB%AF%E8%BF%90%E7%BB%B4/"},{"name":"Windows","slug":"操作系统/Windows","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"软件使用","slug":"软件使用","link":"/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"},{"name":"项目部署","slug":"后端运维/项目部署","link":"/categories/%E5%90%8E%E7%AB%AF%E8%BF%90%E7%BB%B4/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}],"pages":[]}